## DaJet Script

[Начало](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/README.md)

### Команда CONSUME

- [Общее описание](#общее-описание)
- Источники данных
  - Регистр сведений исходящих сообщений
  - Таблица регистрации изменений плана обмена
- Приёмники данных
  - Входящая таблица-очередь базы данных
  - Хранимая процедура базы данных
  - Топик или очередь RabbitMQ
  - Топик Apache Kafka
  - Вызов метода Web API
  - Пользовательский обработчик на C#
- Дополнительные материалы
  - [Методика РИБ 2.0](https://zhichkin.github.io/mp4/rib20.mp4) (видео mp4)
  - [Методика РИБ 2.0](https://zhichkin.github.io/distributed-info-bases-2-0.pdf) (слайды pdf)

#### Общее описание

Команда **CONSUME** реализована DaJet Script специально для работы с таблицами СУБД, которые используются как очереди. Это могут быть очереди сообщений, событий или заданий для асинхронной обработки данных, организации обмена данными или решения любых других аналогичных задач. В контексте 1С:Предприятие 8 такими таблицами-очередями могут быть, например, таблицы регистрации изменений планов обмена или регистры сведений исходящих сообщений. Использование команды **CONSUME** дополняется [механизмом управления последовательностью](https://github.com/zhichkin/dajet/blob/main/doc/dajet-script/sequence/README.md), а всё это, вместе взятое, призвано поддержать применение **методики РИБ 2.0** на практике.

Команда **CONSUME** проектировалась таким образом, чтобы работать по принципу круглосуточной службы, целью которой является максимально эффективная обработка таблицы-очереди. Исходя из этого, хостинг скриптов, использующих команду **CONSUME**, целесообразно осуществлять при помощи [утилиты dajet](https://github.com/zhichkin/dajet/blob/main/doc/dajet-utility/README.md).

**Функциональность команды CONSUME**

1. Выполнение всех действий только в транзакции СУБД, что гарантирует отсутствие потерь данных (записей таблицы-очереди) в случае возникновения ошибок, недоступности сетевых служб и прочих нештатных ситуаций.
2. Обработка данных в определённом пользователем порядке, используя необязательное предложение **ORDER BY**. Для максимальной   производительности рекомендуется использовать сортировку по полям кластерного индекса таблицы-очереди, соответствующую порядку следования этих полей в индексе и направлению их сортировки.
3. Комбинированное применение пунктов 1 и 2 позволяет обеспечить гарантию доставки уровня ```at least once in order``` (минимум один раз в заданном порядке FIFO).
4. Пакетная обработка записей таблицы-очереди в целях оптимизации сетевого взаимодействия с базой данных и, как вариант, брокерами сообщений. Размер пакета (batch) определяется ключевым словом ```TOP``` команды **CONSUME**. Пакетная обработка значительно повышает производительность доставки данных. Рекомендуемый размер пакета, подходящий для большинства случаев - 1000 записей таблицы-очереди.
5. Удаление записей таблицы-очереди (очистка) только при успешном завершении транзакции обработки пакета, сразу же в момент её фиксации.
6. Гибкое подключение разнообразных приёмников данных, используя следующие команды:
   - INSERT (входящая таблица-очередь базы данных приёмника)
   - PRODUCE (брокер RabbitMQ или Apache Kafka)
   - REQUEST (хранимая процедура или вызов web api)   
   - PROCESS (пользовательский обработчик на C#)
8. Возможность фильтрации записей таблицы-очереди при помощи предложения **WHERE**. Это очень полезная возможность для реализации сценариев, например, многопоточной обработки очереди. В данном случае для улучшения производительности может быть рекомендовано использование дополнительных индексов.
9. Возможность высококонкурентной обработки таблицы-очереди параллельно выполняемыми скриптами или при помощи команды **FOR ... MAXDOP**. Чаще всего на практике этого не требуется, однако, если, например, возникает необходимость обработать большую очередь, которая может накопиться в случае очень долгого простоя, то такая возможность будет не лишней.
10. Защита от сбоев реализована таким образом, что, в случае возникновения любой нештатной или непредвиденной ситуации, команда **CONSUME** "засыпает" на ```60 секунд```, а затем пытается продолжить свою работу в штатном режиме. Всё это происходит в бесконечном цикле, пока не будет остановлена программа, которая является хостом для скрипта. Например, можно вполне безопасно обновлять конфигурацию информационной базы 1С:Предприятие 8 в монопольном режиме, не останавливая работу утилиты dajet. Когда база данных 1С будет снова доступна, команда **CONSUME** продолжит свою работу как ни в чём не бывало.

[Наверх](#команда-consume)

**Схема выполнения команды CONSUME**

![Схема выполнения команды CONSUME](https://github.com/zhichkin/dajet/blob/main/doc/img/dajet-script-database-consume-to-database-schema.png)

**Диаграмма выполнения транзакции для одного пакета из 1000 записей**

![Диаграмма выполнения транзакции](https://github.com/zhichkin/dajet/blob/main/doc/img/dajet-script-database-consume-to-database.png)

**Пример кода DaJet Script для обмена СУБД >> СУБД**
```SQL
DECLARE @message object

-- База данных источник
USE 'mssql://sa:sa@localhost:1433/source-database'

   CONSUME TOP 10
           НомерСообщения, Заголовки
         , ТипСообщения, ТелоСообщения
      INTO @message
      FROM РегистрСведений.ИсходящиеСообщения
     ORDER BY НомерСообщения ASC

   -- База данных приёмник
   USE 'pgsql://postgres:postgres@localhost:5432/target-database'

      INSERT РегистрСведений.ВходящиеСообщения
      SELECT Отправитель    = 'DaJet Script'
           , НомерСообщения = VECTOR('so_incoming_queue')
           , Заголовки      = @message.Заголовки
           , ТипСообщения   = @message.ТипСообщения
           , ТелоСообщения  = @message.ТелоСообщения

   END -- Контекст базы данных приёмника

END -- Контекст базы данных источника
```

**Код для Microsoft SQL Server, который генерирует DaJet Script**
```SQL
WITH queue AS 
(SELECT TOP (10)
_Fld135 AS НомерСообщения,
_Fld220 AS Заголовки,
_Fld137 AS ТипСообщения,
_Fld138 AS ТелоСообщения
FROM _InfoRg134 WITH (ROWLOCK, READPAST)
ORDER BY
_Fld135 ASC)
DELETE queue
OUTPUT
deleted.НомерСообщения,
deleted.Заголовки,
deleted.ТипСообщения,
deleted.ТелоСообщения
```

**Код для PostgreSQL, который генерирует DaJet Script**
```SQL
WITH filter AS 
(SELECT
_fld99,
_fld100
FROM _InfoRg98
ORDER BY
_Fld99 ASC
LIMIT 10
FOR UPDATE SKIP LOCKED)
, queue AS 
(DELETE FROM _InfoRg98 AS source USING filter
WHERE (source._fld99 = filter._fld99
AND source._fld100 = filter._fld100)
RETURNING
source._Fld99 AS НомерСообщения,
source._Fld101 AS ТипСообщения,
source._Fld102 AS ТелоСообщения)
SELECT
queue.НомерСообщения,
queue.ТипСообщения,
queue.ТелоСообщения
FROM queue
ORDER BY
queue.НомерСообщения ASC
```

[Наверх](#команда-consume)

**Взаимодействие с брокерами RabbitMQ и Apache Kafka**

![Схема выполнения команды CONSUME](https://github.com/zhichkin/dajet/blob/main/doc/img/dajet-script-database-consume-to-rabbitmq-schema.png)

![Схема выполнения команды CONSUME](https://github.com/zhichkin/dajet/blob/main/doc/img/dajet-script-database-consume-to-rabbitmq.png)

[Наверх](#команда-consume)
