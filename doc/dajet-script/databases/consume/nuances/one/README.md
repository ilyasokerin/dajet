## DaJet Script

[CONSUME](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/databases/consume/README.md)

### Команда CONSUME, нюанс № 1

Для более глубокого понимания того, как работает команда **CONSUME** рассмотрим два практических примера: первый без использования опции ```WITH STRICT ORDER``` (стандартное рекомендуемое применение), и второй - с использованием этой опции. В конце статьи будет объяснено принципиальное отличие использования команд **CONSUME** и **STREAM**.

> Поведение опции ```WITH STRICT ORDER```, описанное в данной статье, относится только к Microsoft SQL Server. Использование этой опции в контексте PostgreSQL не имеет существенного значения. Если эта опция не используется, то поведение команды **CONSUME** для Microsoft SQL Server и PostgreSQL аналогично.

Прежде, чем начать, необходимо объяснить использование хинтов ```ROWLOCK``` и ```READPAST``` в коде SQL, который генерирует DaJet Script, для Microsoft SQL Server, а также ```FOR UPDATE``` и ```SKIP LOCKED``` для PostgreSQL.

Назначение хинтов ```ROWLOCK``` и ```FOR UPDATE``` в команде **CONSUME** - это намерение получить эксклюзивную блокировку записи таблицы-очереди, чтобы убедиться в том, что команда будет обрабатывать транзакционно зафиксированные данные. Это очень важно для избежания ситуации обработки "фантомных" данных, которые возможно не будут зафиксированы. То есть без получения эксклюзивной блокировки есть высокий риск отправить в целевую систему обмена данными такие записи таблицы-очереди, которые в конечном итоге не были созданы или имеют неактуальные данные.

В свою очередь хинты ```READPAST``` и ```SKIP LOCKED``` изменяют реакцию команды **CONSUME** на заблокированные другими транзакциями записи таблицы-очереди. Эти хинты "разрешают" команде **CONSUME** пропускать такие записи, не ожидая снятия блокировки, и продолжать обрабатывать следующие за ними по порядку доступные записи. Это позволяет повысить параллельность работы с таблицей-очередью в сценариях многопоточной обработки очереди несколькими командами **CONSUME** одновременно (разными скриптами). Здесь следует заметить, что побочным эффектом таких сценариев может являться нарушение последовательсности обработки данных. Не всегда это критично, но всё же.

> Использование опции ```WITH STRICT ORDER``` убирает из кода SQL хинты ```READPAST``` и ```SKIP LOCKED```. Таким образом это может привести к ожиданию на блокировках вплоть до получения ошибки превышения таймаута.<br>Объяснить зачем эта опция может быть нужна - цель данной статьи.

Для демонстрации примеров будет использован регистр сведений 1С:Предприятие 8 "ОчередьИсходящихСообщений", имеющий следующую структуру метаданных:

|**Свойство**|**Назначение**|**Тип данных**|
|------------|--------------|--------------|
|НомерСообщения|Измерение|Число(15,0)|
|ТипСообщения|Ресурс|Строка(1024)|
|ТелоСообщения|Ресурс|Строка(0)|

Данный регистр (непериодический и независимый) будет иметь кластерный индекс по единственному полю "НомерСообщения".

**Пример № 1 без использования опции ```WITH STRICT ORDER```**



[Наверх](#команда-consume-нюанс--1)
