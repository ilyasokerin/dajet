## DaJet Script

[CONSUME](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/databases/consume/README.md)

### Команда CONSUME, нюанс № 1

Для более глубокого понимания того, как работает команда **CONSUME** рассмотрим два практических примера: первый без использования опции ```WITH STRICT ORDER``` (стандартное рекомендуемое применение), и второй - с использованием этой опции. В конце статьи будет объяснено принципиальное отличие использования команд **CONSUME** и **STREAM**. Для демонстрации примеров будет использована Microsoft SQL Server Management Studio. Работа с базой данных 1С:Предприятие 8 будет выполняться в режиме управляемых блокировок, то есть у базы данных будет включена опция ```read committed snapshot```.

> Поведение опции ```WITH STRICT ORDER```, описанное в данной статье, относится только к Microsoft SQL Server. Использование этой опции в контексте PostgreSQL не имеет существенного значения. Если эта опция не используется, то поведение команды **CONSUME** для Microsoft SQL Server и PostgreSQL аналогично.

Прежде, чем начать, необходимо объяснить использование хинтов ```ROWLOCK``` и ```READPAST``` в коде SQL, который генерирует DaJet Script, для Microsoft SQL Server, а также ```FOR UPDATE``` и ```SKIP LOCKED``` для PostgreSQL.

Назначение хинтов ```ROWLOCK``` и ```FOR UPDATE``` в команде **CONSUME** - это намерение получить эксклюзивную блокировку записи таблицы-очереди, чтобы убедиться в том, что команда будет обрабатывать транзакционно зафиксированные данные. Это очень важно для избежания ситуации обработки "фантомных" данных, которые возможно не будут зафиксированы. То есть без получения эксклюзивной блокировки есть высокий риск отправить в целевую систему обмена данными такие записи таблицы-очереди, которые в конечном итоге не были созданы или имеют неактуальные данные.

В свою очередь хинты ```READPAST``` и ```SKIP LOCKED``` изменяют реакцию команды **CONSUME** на заблокированные другими транзакциями записи таблицы-очереди. Эти хинты "разрешают" команде **CONSUME** пропускать такие записи, не ожидая снятия блокировки, и продолжать обрабатывать следующие за ними по порядку доступные записи. Это позволяет повысить параллельность работы с таблицей-очередью в сценариях многопоточной обработки очереди несколькими командами **CONSUME** одновременно (разными скриптами). Здесь следует заметить, что побочным эффектом таких сценариев может являться нарушение последовательсности обработки данных. Не всегда это критично, но всё же.

> Использование опции ```WITH STRICT ORDER``` убирает из кода SQL хинты ```READPAST``` и ```SKIP LOCKED```. Таким образом это может привести к ожиданию на блокировках вплоть до получения ошибки превышения таймаута.<br>Объяснить зачем эта опция может быть нужна - цель данной статьи.

Для демонстрации примеров будет использован регистр сведений 1С:Предприятие 8 "ОчередьИсходящихСообщений", имеющий следующую структуру метаданных:

|**Свойство**|**Назначение**|**Тип данных**|
|------------|--------------|--------------|
|НомерСообщения|Измерение|Число(15,0)|
|ТипСообщения|Ресурс|Строка(1024)|
|ТелоСообщения|Ресурс|Строка(0)|

Данный регистр (непериодический и независимый) будет иметь кластерный индекс по единственному полю "НомерСообщения".

[Наверх](#команда-consume-нюанс--1)

**Пример № 1 без использования опции ```WITH STRICT ORDER```**

**Шаг 1.** Транзакция A: откроем новую панель запросов и выполним следующий код SQL. Этот код добавит три новых сообщения в таблицу-очередь и будет "спать" 30 секунд прежде, чем зафиксирует свою транзакцию. Таким образом мы эмулируем длинную траназкцию. Итогом выполнения скрипта будет "подвисание" панели запросов на 30 секунд.

```SQL
BEGIN TRANSACTION;

SET NOCOUNT ON;

INSERT _InfoRg123 SELECT 1, 'type', 'body';
INSERT _InfoRg123 SELECT 2, 'type', 'body';
INSERT _InfoRg123 SELECT 3, 'type', 'body';

WAITFOR DELAY '00:00:30.000';

COMMIT TRANSACTION;
```

**Шаг 2.** Транзакция B: откроем новое окно панели запросов и выполним следующий код SQL. Этот код также добавит три новых сообщения в таблицу-очередь, но зафиксирует свою транзакцию сразу без ожидания. Итогом выполнения скрипта будет моментальное его завершение.

```SQL
BEGIN TRANSACTION;

SET NOCOUNT ON;

INSERT _InfoRg123 SELECT 4, 'type', 'body';
INSERT _InfoRg123 SELECT 5, 'type', 'body';
INSERT _InfoRg123 SELECT 6, 'type', 'body';

COMMIT TRANSACTION;
```

**Шаг 3.** Транзакция C: откроем новое окно панели запросов и выполним следующий код SQL. Этот код просто проверяет наличие сообщений в таблице очереди. Обратите внимание, что используется хинт **NOLOCK**, который позволяет выполнить "грязное" чтение и получить все записи таблицы, в том числе ещё незафиксированной транзакции A. Итогом выполнения скрипта будет таблица приведённая ниже. Скрипт выполнится моментально.

```SQL
SELECT _Fld124 AS НомерСообщения,
       _Fld125 AS ТипСообщения,
       _Fld126 AS ТелоСообщения
  FROM _InfoRg123 WITH (NOLOCK)
```

**Результат выполнения скрипта**
|**НомерСообщения**|**ТипСообщения**|**ТелоСообщения**|
|------------------|----------------|-----------------|
|1|type|body|
|2|type|body|
|3|type|body|
|4|type|body|
|5|type|body|
|6|type|body|

**Шаг 4.** Транзакция D: откроем новое окно панели запросов и выполним следующий код SQL. Этот код эмулирует выполнение команды **CONSUME** без опции ```WITH STRICT ORDER```. Итогом выполнения скрипта будет таблица приведённая ниже. Скрипт выполнится моментально.

> **Важно!** Нужно успеть выполнить скрипт до того, как завершиться транзакция A.

```SQL
WITH queue AS 
(SELECT TOP (10)
        _Fld124 AS НомерСообщения,
        _Fld125 AS ТипСообщения,
        _Fld126 AS ТелоСообщения
   FROM _InfoRg123 WITH (ROWLOCK, READPAST)
  ORDER BY _Fld124 ASC)
DELETE queue
OUTPUT deleted.НомерСообщения,
       deleted.ТипСообщения,
       deleted.ТелоСообщения;
```
**Результат выполнения скрипта**
|**НомерСообщения**|**ТипСообщения**|**ТелоСообщения**|
|------------------|----------------|-----------------|
|4|type|body|
|5|type|body|
|6|type|body|

**Шаг 5.** Прейдём на панель запросов транзакции A и дождёмся её успешного завершения с фиксацией транзакции.

**Шаг 6.** Прейдём на панель запросов транзакции D и выполним скрипт ещё раз, он выполнится моментально. Итогом выполнения будет ниже следующая таблица.

**Результат выполнения скрипта**
|**НомерСообщения**|**ТипСообщения**|**ТелоСообщения**|
|------------------|----------------|-----------------|
|1|type|body|
|2|type|body|
|3|type|body|

**Шаг 7.** Выполним скрипт транзакции D ещё раз. Итогом его выполнения будет пустая таблица - очередь пуста. Мы обработали все сообщения.

**Выводы**

Итак, мы получили нарушение последовательности сообщений. Сначала мы получили сообщения 4, 5 и 6, а затем - 1, 2 и 3. Кто виноват и что делать?

На самом деле это штатное поведение команды **CONSUME** без использования опции ```WITH STRICT ORDER```. Это рекомендованное использование команды **CONSUME**. Нарушаем ли мы таким образом последовательсность формирования сообщений? Безусловно да. Однако намного важнее другой вопрос: нарушаем ли мы таким образом согласованность данных в двух узлах обмена данными - источнике и приёмнике?

[Наверх](#команда-consume-нюанс--1)
