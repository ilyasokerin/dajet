## DaJet Script

[Команда EXECUTE](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/execute/README.md)

### Асинхронный вызов скриптов

Внешний или подключаемый скрипт можно вызвать асинхронно при помощи опций **TASK** или **WORK** команды **EXECUTE**. В том и другом случае скрипт будет выполнен асинхронно в другом потоке операционной системы, а не в текущем потоке вызова. Разница между двумя этими опциями заключается в том, что в первом случае поток выполнения "арендуется" из пула потоков .NET, а во втором - создаётся отдельный поток операционной системы. Опцию **TASK** рекомендуется использовать для коротких небольших заданий, а **WORK** наоборот для долгих, возможно "вечных", процессов.

Полный синтаксис асинхронной команды **EXECUTE** выглядит следующим образом:
```
EXECUTE [{ TASK | WORK }] 'file://<async-script>.djs'
[DEFAULT 'file://<default-script>.djs']
[WITH <parameters>]
[INTO <array-of-tasks>]
```

Команда **EXECUTE** создаёт и добавляет в переменную ```array``` объекты ```task```. Такой массив необходимо заранее объявить именно для этих целей в шапке вызывающего родительского скрипта. Ссылка на этот массив указывется в необязательном предложении **INTO** команды **EXECUTE**. Добавление ```task``` в ```array``` выполняется после запуска дочернего потока или помещения задания в очередь на выполнение пулом потоков .NET. Доступ к массиву заданий осуществляется обычным для типа ```array``` способом. Элементами массива объекты, которые имеют следующую структуру:

|Свойство|Тип<br>данных|Описание|
|--------|-------------|--------|
|Id|number|Системный идентификатор потока|
|Status|string|Текущее состояние потока|
|Result|любое<br>значение|Результат выполнения задания|
|IsFaulted|boolean|Признак завершения потока из-за ошибки|
|IsCanceled|boolean|Признак завершения потока системой|
|IsCompleted|boolean|Признак завершения выполнения потока|
|IsSucceeded|boolean|Признак завершения потока без ошибок|

**Таблица состояний потока (свойство "Status")**
|Значение|Описание|
|--------|--------|
|Created|Задание создано, но ещё не запланировано к выполнению системой|
|WaitingToRun|Задание запланировано и ожидает начала выполнения|
|Running|Задание выполняется|
|WaitingForChildrenToComplete|Задание выполнено и неявно ожидает завершения, подключенных дочерних задач|
|RanToCompletion|Задание выполнено без ошибок|
|Canceled|Выполнение задания прервано системой по сигналу немедленного завершения|
|Faulted|Задание завершилось из-за необработанной ошибки|

Для синхронизации выполнения, созданных таким образом дочерних потоков, используется команда **WAIT**. Эта команда синхронно ожидает завершения всех или одного любого потока из указанного массива заданий (опции **ALL** и **ANY** соответственно). На время своего ожидания команда **WAIT** блокирует выполнение текущего родительского потока. Опция **ANY** требует обязательного использования передложения **INTO**, где указывается ссылка на переменную, в которую будет возвращено значение завершившегося задания. Такую переменную необходимо объявить заранее именно для этих целей в шапке вызывающего родительского скрипта.

Полный синтаксис команды **WAIT** выглядит следующим образом:
```
WAIT [{ ALL | ANY }] <array-of-tasks> [INTO <task>]
```

Команда **WAIT** получает и помещает результат выполнения каждого дочернего потока в свойство "Result" соответствующего объекта ```task```. Внешний скрипт может возвращать результат своей работы вызывающему родительскому скрипту при помощи команды **RETURN**. Если эта команда не используется, то в свойство "Result" возвращается значение ```NULL```. Кроме этого команда **WAIT** выполняет перехват всех, необработанных дочерними скриптами, ошибок. Описание ошибки сохраняется в том же самом свойстве "Result" как текст (тип данных ```string```). Результат выполнения доступен только после полного завершения работы потока через соответствующий ему объект ```task```.

> Если команда **WAIT** не используется, то выполнение дочерних потоков продолжается даже тогда, когда родительский скрипт уже завершился и его поток уничтожен операционной системой. Таким образом время жизни дочерних потоков совпадает со временем жизни хоста DaJet Script, то есть процессом операционной системы, в котором работает такой хост.







[Наверх](#асинхронный-вызов-скриптов)
